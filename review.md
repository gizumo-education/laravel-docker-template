# Laravel Lesson レビュー①

## Todo一覧機能

### Todoモデルのallメソッドで実行しているSQLは何か
レコードを全件取得する処理を行っている。
SELECT * FROM ‘todos’;というSQL文を、記述せずにDB操作を行っている。

### Todoモデルのallメソッドの返り値は何か
Collectionインスタンスが返り値になる。

### 配列の代わりにCollectionクラスを使用するメリットは
Collectionクラスには、map、filter、reduce、pluck、groupByなどのメソッドが標準で準備されていて可読性の高いコードが書けることや、求めたKeyが取得できなかった時などにnullを返す（エラーメッセージを準備しなくていい場面で活用できる）ことがメリットとして挙げられる。

### view関数の第1・第2引数の指定と何をしているか
第一引数で画面に表示したいbladeファイルを指定し、
第二引数は[blade内での変数名 => 代入したい値]と書くことで、連想配列の形でデータを渡すことができる。

例：return view('todo.index', ['todos' => $todos]);
⇒todoファイル内にあるindex.blade.phpを画面に表示するよう指定し、blade.index.phpにある'todos'という変数にはTodocontroller.phpの処理で定義された$todosを代入して渡すよう記述している。

### index.blade.phpの$todoList・$todoに代入されているものは何か
$todoには、$todosの配列データ一つ一つがforeachによって代入されている。（また、現時点で$todoListは定義されていない。）

## Todo作成機能

### Requestクラスのallメソッドは何をしているか
フォームから入力されたデータを連想配列の形で取得している。
    public function store(Request $request)
    {
        $inputs = $request->all();

        $todo = new Todo();
        $todo->fill($inputs);
        $todo->save();

        return redirect()->route('todo.index');
    }
上記の(Request $request)という記述から、Requestインスタンスを$requestに格納し、Requestインスタンスのメソッドであるallメソッドを使い、入力された値を連想配列の形で取得し、その結果を$inputsへ格納している。

### fillメソッドは何をしているか
fillメソッドは、連想配列の形で値を指定すると、複数のカラムに値をセットする（データの追加・更新に利用できる）処理を行う。今回の場合は、引数として渡した$inputsに格納された入力値の連想配列のデータを、DBの複数カラムにセットしている。

### $fillableは何のために設定しているか
一括代入を許可する属性を指定するために設定している。

例えば、$inputsに格納された連想配列のデータが、
[ 'content' => 'りんご', ‘other’ => ’おはよう’ ]だった場合、$todo->fill($inputs)の処理によって $todo->content には 'りんご' が設定されるが、$todo->otherは無視される（$fillableにotherという属性は含まれていないため許可されない）。
また、一括代入をマス・アサインメントと呼ぶこともある。

### saveメソッドで実行しているSQLは何か
saveメソッドは、INSERTやUPDATEの処理を実行している。
・新規レコードの作成（INSERT）：新しいインスタンスを作成し、saveメソッドを呼び出すことで新規レコードがDBへ挿入される。Saveが呼び出された時点でcreate_atとupdated_atのタイムスタンプは自動で設定される。
・レコードの更新（UPDATE）：既にあるモデルを取得し、更新したい属性をセットしてからsaveメソッドを呼び出すことで、DBの既存レコードが更新される。

### redirect()->route()は何をしているか
まずredirect関数を引数なしで呼び出し、結果としてリダイレクタインスタンスが返る。
続いて、リダイレクタインスタンスのメソッドが呼び出せるようになり、routeメソッドを使うことで名前付きルートに対するURLを生成できる。

今回の場合、route('todo.index')のため、'todo.index'というルートに対応するURLを生成してリターンし、リダイレクトレスポンスを受け取ったブラウザは指定されたURLのページを表示することになる。
（'todo.index'というルートの定義はweb.php内にある
⇒Route::get('/todo', 'TodoController@index')->name('todo.index');）

### RequestクラスからFormRequestクラスに変更した理由
※まだクラスの変更をしていないため、後ほど回答

### $errorsのhasメソッドの引数・返り値は何か
※$errorsに関する処理をまだ行っていないため、後ほど回答

### $errorsのfirstメソッドの引数・返り値は何か
※$errorsに関する処理をまだ行っていないため、後ほど回答

## その他

### テーブル構成をマイグレーションファイルで管理するメリット
マイグレーションファイルでテーブル構成を管理すると、SQLを知らなくてもPHPのコードでテーブル操作ができることや、マイグレーションファイルをGitで共有することで、開発者同士のテーブル構成を統一して作業ができるといったメリットがある。
（マイグレーションとは、Laravelにある機能の一つで、DBのテーブルを作成することができる。ちなみに、レコードを作成することができるLaravelの機能はSeederと呼ぶ。）

### マイグレーションファイルのup()、down()は何のコマンドを実行した時に呼び出されるのか
upメソッドはDBに新しいテーブルやカラムやインデックスを追加するための処理が書かれており、php artisan migrateと書いてartisanコマンドを実行すると呼び出される。
一方downメソッドはテーブルを削除するための処理を記述しており、upメソッドの操作とは逆の操作を実装している。php artisan migrate:rollbackと書いてrollbackコマンドを実行すると呼び出される。

### Seederクラスの役割は何か
テストデータをtodoテーブルに投入する役割を担っている。

まず、作成したSeederファイルのrunメソッドにテストデータ作成のための処理を記述し、続いてDatabaseSeeder.php でSeederファイルをコールするとSeederが実行されてテストデータがDBに挿入される。
（また、TodoSeeder.phpのrunメソッドの最初にDB::table('todos')->truncate();と記述しているが、これはテストデータ投入時に開発者間のテストデータに差が出ないようにするために、todoテーブルのレコードを全て削除するよう設定している。）

### TodoControllerクラスのコンストラクタはどのタイミングで実行されるか
TodoControllerインスタンスが生成されたタイミングで実行される。
まずブラウザから/todoに対するリクエストが来た時に、対応したルートを探す。次にTodoControllerのインスタンスが生成され、その時にコンストラクタが実行される。その後、生成されたTodoControllerインスタンスのindexメソッドが実行される。

### route関数の引数・返り値・使用するメリット
引数：ルート名を指定する。
返り値：指定されたルート名を使ったURLを生成して返す。
メリット：URLに変更があってもルート名に変更がなければ修正箇所がweb.phpのみで済むため、コードの保守性が向上するメリットがある。

### @extends・@section・@yieldの関係性とbladeを分割するメリット
@extends：引数にresources/views/以降のパスをドット区切りで書くことで、継承する親bladeファイルを指定する。
@section：親bladeファイルに挿入する部分を、@section~@endsectionで囲んで指定する。
@yield：＠sectionで囲った部分が挿入される場所。引数に＠sectionと同じ文字列を指定することで、紐づけることができる。
Bladeを分割するメリット：重複するコードをbase.blade.phpに書くことで、コードを再利用でき、保守性やファイルの可読性が向上するというメリットがある。

### @csrfは何のための記述か
CSRF対策として、フォームから入力データを送信する時に、トークンも一緒に送信するために記述している。

### {{ }}とは
bladeファイルでphpを記述する時に使うのが{{ }}。波括弧で囲った部分がphpの処理として認識され、同時にエスケープ処理も行われる。
似た記法で{!! !!}というものもあるが、こちらはエスケープ処理が行われないという特徴がある。

